<!DOCTYPE html>
<!-- This one's started with the framework, happened after Seed Saver
It's like timed hunting, but energy instead of stamina -->
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Conquer and Grow</title>
<script>history.scrollRestoration = "manual"</script>
  <style>
    body {
      background: pink;
      margin: 0;
      padding: 0;
      width: 1642.2px;
      height: 1642.2px;
      overflow: hidden;
    }
    #map {
      background: lightgray;
      position: absolute;
      width: 1642.2px;
      height: 1642.2px;
      transition: all linear 200ms;
    }
    .rows {
      z-index: 1;
      width: 1642.2px;
      height: 32.2px;
    }
    span {
      position: relative;
      width: 32px;
      height: 32px;
      overflow: visible;
      display: inline-block;
      padding:0;
      margin:0;
      border: solid .1px lightgray;
      z-index: 1;
    }
    .blank {
      background: ghostwhite;
      transition: all ease .05s;
    }
    .char {
      position: fixed;
      z-index: 5;
      top: 50%;
      left: 50%;
    }
    .charPath {
      transition-delay: 200ms;
    }
    p {
      color: black;
      width: 16px;
      height: 16px;
      position: fixed;
      z-index: 6;
      text-shadow: -1px 0 ghostwhite, 0 1px ghostwhite, 1px 0 ghostwhite, 0 -1px ghostwhite;
      font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
    }
    .charTime {
      color: white;
      margin: 3px 0 0 6px;
    }
    #statBar {
      background: rgba(210, 75, 75, 0.5);
      height: 40px;
      width: 100vw;
      position: absolute;
      z-index: 2;
    }
    .statAsp {
      background: none;
      color: white;
      margin: 0 0 0 10px;
      display: inline;
    }
    #congrats {
      width: 50px;
      display: block;
      margin: -20px auto;
      border: none;
      font-size: 20px;
    }
    #fillBar {
      background: none;
      height: 10px;
    }
    #holder {
      width: 50vw;
      height: 50vh;
      background: white;
      border-radius: 25px;
      position: absolute;
      left: 25%;
      top: 25%;
    }
    .holder {
      position: absolute;
      width: 16vw;
      height: 50vh;
    }
    #hold1 {
      margin: 30px 0 0 2vw;
    }
    #hold2 {
      margin: 30px 0 0 18.5vw;
    }
    #hold3 {
      margin: 30px 0 0 35vw;
    }
    button {
      cursor: pointer;
    }
    #beginner {
      background: pink;
      color: white;
      border: none;
      width: 42vw;
      height: 50px;
      margin: 4vw 0 0 4vw;
    }
    input {
      position: relative;
      cursor: pointer;
      margin: 0 0 0 10px;
    }
    .info {
      position: relative;
      margin: 0 0 0 20px;
      width: 50vw;
      height: 20px;
    }
  </style>
</head>
<body scroll="no">
  <script>
    //Map default values
    var mappy = document.createElement('div'); mappy.id = 'map';
    var mapX; var mapY; var mapXNum = 51; var mapYNum = 51; var sSize = 32.2;
    var berryCol = 'yellow'; var backCol = 'pink';
    var colorSchema = [
      ['#db9c58', '#f26f6f', '#eb564b', '#b5423a', '#7a302b'],
      ['#2c93e8', '#00ffe5', '#13d4c0', '#0ca696', '#148579'],
      ['#48e895', '#78ff03', '#72de14', '#54a60d', '#518a20'],
      ['#846cf0', '#8000ff', '#7617d4', '#58119e', '#552287'],
      ['#f04363', '#ff00a2', '#ff00a2', '#b01778', '#8f2167'],
      ['#e6d44c', '#fccb05', '#deb614', '#b59410', '#8f781b']
    ]
    //Character variables
    var char = document.createElement('span')
    var charTime = document.createElement('p')
    //Variables for moving
    var moving; var pathX = 0; var pathY = 0; var lefts; var ups;
    var newPath = false; var move = '';
    //Filling variables
    var arrX = []; var arrY = []; var parity = [0,0,0,0];
    var line = false; var end = false; var dont = false;
    var innards = [];  var remover = [];
    //Variables for Statistics
    var sBlankNum; var nBlankNum; var filledFrac = 0;
    var win = false; var seedWin = false; var terrWin = false;
    var dead = false; var replay = false; var retry = false;
    //Holds the state of the game. LavaC, SeedsC, SaveC etc.
    var checkArr = [false, false, false, false]
    var shp = 'default'; var moveSpeed;
    //Time limit variables
    var time; var timed; var timer; var timing = false;
    var enerPlus = 1000; var stamPlus = 200;
    //Defining holders for the menu
    var holder; var minHold1; var minHold2; var minHold3;
    //Stat Bar Setup
    var sBar = document.createElement('div'); sBar.id = 'statBar';
    var fillBar = document.createElement('div'); fillBar.id = 'fillBar';
    var barPerc = document.createElement('div')
    barPerc.id = 'barPerc'; barPerc.className = 'statAsp';
    sBar.appendChild(fillBar); sBar.appendChild(barPerc);
    //Extra Stat Bar Variables
    var seedNum = 0; var startSeedNum = 60; var stamina = 5000;
    var barSeed = document.createElement('div')
    barSeed.id = 'barSeed'; barSeed.className = 'statAsp';
    var barStam = document.createElement('div')
    barStam.id = 'barStam'; barStam.className = 'statAsp';
    sBar.appendChild(barSeed); sBar.appendChild(barStam);
    //Congrats setUp
    var congrats = document.createElement('div')
    congrats.id = 'congrats'; congrats.className = 'statAsp';
    sBar.appendChild(congrats);

    //Change Color Values
    function colChange(colNum) {
      charCol = colorSchema[colNum][0]; charPathCol = colorSchema[colNum][1];
      charTerColI = colorSchema[colNum][2]; charTerColP = colorSchema[colNum][3];
      charTerColS = colorSchema[colNum][4]; char.style.background = charCol;
    }
    //Create starting territory
    function terrStart(x, y) {
      for (let i = 0; i < 3; i++) { for (let j = 0; j < 3; j++) {
        let terr = document.getElementById((Math.round(mapXNum/2) + i - 2)+ 'n' + (Math.round(mapYNum/2) + j - 2))
        terr.className = 'charTerP'; terr.classList.remove('blank');
        terr.style.background = charTerColS
      }}
    }
    //Place character in the center of the starting territory
    function charStart() {
      var charNum = 0; char.id = 'char' + charNum;
      char.className = 'char'; char.style.background = charCol;
      document.body.appendChild(char)
      if (checkArr[1] || checkArr[3]) {
        charTime.id = 'charTime' + charNum; charTime.className = 'charTime';
        char.appendChild(charTime)
      }
    }
    //Populate the map with repNum number of seeds
    function seedPopulate(repNum) {
      for (i = 0; i<repNum; i++) {
        blanks = document.getElementsByClassName('blank')
        blankNum = Math.round((Math.random()*(blanks.length)))-1
        if (blanks[blankNum]) {
          var berry = blanks[blankNum]
          berry.className = 'berry'; berry.classList.remove('blank');
          berry.style.borderRadius = '50%'; berry.style.background = berryCol;
        }
      }
    }

    //Turns blank grids into path grids
    function pathMaker(x,y) {
      let path = document.getElementById(x + 'n' + y); statZ();
      if (!path) {
        deathScene(true)
        //If the space is blank, make it a path
      } else if (path.className === 'blank') {
        //Also, if on a timed mode, set a timer
        if (timing === false && (checkArr[1]||checkArr[3])) {
          //If on timed hunting, reset timer; otherwise, keep time same as it ended last
          if (checkArr[1] && !checkArr[3]) { stamina = 5000; }
          timing = true; timed = setTimeout(function() {deathScene(true);}, stamina);
          timer = setInterval(function() {charTime.innerHTML = Math.round(stamina)/1000; stamina = (stamina - 100);}, 100)
        }
        path.className = 'charPath'; path.classList.remove('blank');
        path.style.background = charPathCol; newPath = true;
        //If the space is a berry, make it a path and collect the berry
      } else if (path.className === 'berry') {
        if (checkArr[3]) {
          stamina = Math.round(stamina + enerPlus)
        } else {
          stamina = Math.round(stamina + stamPlus)
        }
        seedNum++; statZ();
        //Also, if on a timed mode, set a timer
        if (timing === false && (checkArr[1] || checkArr[3])) {
          //If on timed hunting, reset timer; otherwise, keep time same as it ended last
          if (checkArr[1] && !checkArr[3]) { stamina = 5000; }
          timing = true; timed = setTimeout(function() {deathScene(true);}, stamina);
          timer = setInterval(function() {charTime.innerHTML = Math.round(stamina)/1000; stamina = (stamina - 100);}, 100)
        } else if (timing === true && (checkArr[1] || checkArr[3])) {
          //Update the time available even when in the middle of a path
          clearTimeout(timed); timed = setTimeout(function() {deathScene(true);}, stamina - (time*1000));
        }
        path.classList.remove('berry'); path.className = 'charPath';
        path.style.borderRadius = '0%'; path.style.background = charPathCol;
        newPath = true
        //If the space is deadly, die
      } else if ((path.className === 'wall' || path.className === 'charPath' || (checkArr[0] && path.className === 'charTer')) && win === false) {
        deathScene(true)
        //If the space is a valid territory, fill in the spaces in the path you've just made
      } else if ((path.className === 'charTerP' || (!checkArr[0] && path.className === 'charTer')) && newPath === true) {
        newPath = false; fillR();
        //Also, if on a timed mode, clear the timer
        //If timed hunting, reset time displays to 5.0sec
        if (timing === true) {
          timing = false; clearTimeout(timed);
          if (checkArr[3]) {
            charTime.innerHTML = Math.round(stamina)/1000
          } else if (checkArr[1]) {
            charTime.innerHTML = '5.0'; barStam.innerHTML = '5.0';
          }
          clearInterval(timer); statZ();
        }
      }
    }
    //Player  Keyboard Controls
    document.onkeydown = function(event) {
      switch (event.keyCode) {
        //In case of Esc, go back to menu, deleting map and statbar, and reinstating options holder
        case 27:
          if (document.body.contains(mappy)) { document.body.removeChild(mappy); mappy.innerHTML = ''; }
          if (document.body.contains(sBar)) { document.body.removeChild(sBar); }
          if (!document.body.contains(holder)) { deathScene(true); deathScene(false); setUpScreen(); }
          break;
        //In case of space, either end or replay the game
        case 32:
          if (dead === true) {
            replay = true; mappy.style.transition = 'all ease 1.5s';
            gameStart()
          } else {
            deathScene(true)
          }
          break;
        //Follow the arrows and change the direction of movement (don't double back)
        case 37: if (move != 'right') {move = 'left'}; break;
        case 38: if (move != 'down') {move = 'up'}; break;
        case 39: if (move != 'left') {move = 'right'}; break;
        case 40: if (move != 'up') {move = 'down'}; break;
      }
    }
    //Center the window and character every second or so
    function mapCenter() {
      //The centering process depends on whether the rows/columns are even or odd
      //(since it's in relation to the character which is always centered)
      if (mapXNum%2 === 0) {
        nMapX = -Math.round(32.2*((mapXNum-2)/2)) + (window.innerWidth/2)
      } else {
        nMapX = -Math.round(32.2*((mapXNum-1)/2)) + (window.innerWidth/2)
      }
      if (mapYNum%2 === 0) {
        nMapY = -Math.round(32.2*((mapYNum-2)/2)) + (window.innerHeight/2)
      } else {
        nMapY = -Math.round(32.2*((mapYNum-1)/2)) + (window.innerHeight/2)
      }
      //If the newly calculated centerings conflict with the current one's, the map is updated
      if (nMapX != mapX) { lefts = lefts - mapX + nMapX; mapX = nMapX; }
      if (nMapY != mapY) { ups = ups - mapY + nMapY; mapY = nMapY; }
      //If the character is dead, there is a special transform and centering process
      if (dead === true) {
        ups = mapY; lefts = mapX - 15;
        mappy.style.transition = 'all ease 1.5s'
        mappy.style.margin = '' + ups + 'px 0 0 ' + lefts + 'px'
        mappy.style.transform = ' scaleX(' + (.65*(window.innerWidth/mappy.clientWidth)) + ') scaleY(' + (.65*(window.innerWidth/mappy.clientWidth)) + ') rotateX(60deg) rotateZ(45deg) '
      } else {
        mappy.style.transform = ''
      }
    }
    //Moves the map to simulate character motion
    function mapMove() {
      //Depending on the key most recently pressed, the movement goes in one direction
      if (move === 'left') {
        lefts = lefts + 32.2; pathX = pathX - 1;
      } else if (move === 'up') {
        ups = ups + 32.2; pathY = pathY - 1;
      } else if (move === 'right') {
        lefts = lefts - 32.2; pathX = pathX + 1;
      } else if (move === 'down') {
        ups = ups - 32.2; pathY = pathY + 1;
      }
      //The pathMaker is called to color in the path, and the map is moved around the character
      pathMaker((pathX + Math.round(mapXNum/2 - 1)), (pathY + Math.round(mapYNum/2 - 1)))
      mappy.style.margin = '' + ups + 'px 0 0 ' + lefts + 'px'
    }
    //Zoom out of board and kill player/restore game to factory settings
    //Depending on the boolean value given for state
    function deathScene(state) {
      if (state) {
        dead = true; clearInterval(moving); clearTimeout(moveSpeed);
        clearInterval(timing); clearInterval(timer); clearInterval(timed);
        mapCenter(); char.style.display = 'none';
        //Calculating the proper 'congrats' message
        if (win === true && seedWin === true && terrWin === true) {
          congrats.innerHTML = 'You won by collecting all the seeds AND by covering the whole map!'
          congrats.style.width = '562px'
        } else if (win === true && seedWin === true) {
          congrats.innerHTML = 'You won by collecting all the seeds!'
          congrats.style.width = '291px'
        } else if (win === true && terrWin === true) {
          congrats.innerHTML = 'You won by covering the whole map!'
          congrats.style.width = '303px'
        } else {
          congrats.innerHTML = 'You lost!'
          congrats.style.width = '73px'
        }
        //Gets rid of ugly borders, but really lags the death process
        //spans = document.getElementsByTagName('span')
        // for (let i = 0; i < spans.length; i++) {
        //   spans[i].style.border = 'none'
        // }
      } else {
        //Reset values and displays
        win = false; seedWin = false; terrWin = false;
        dead = false; replay = false; timing = false;
        pathX = 0; pathY = 0; newPath = false; move = '';
        seedNum = 0; stamina = 5000; time = 0;
        lefts = mapX; ups = mapY;
        charTime.innerHTML = '5.0'
        mappy.style.margin = '' + ups + 'px 0 0 ' + lefts + 'px'
        //Turn all spans back to blank territory
        spans = document.getElementsByTagName('span')
        for (let i = 0; i < spans.length; i++) {
          var sClass = spans[i].getAttribute('class')
          if (sClass != 'char') {
            //Used in conjunction with border removal with state = true
            // spans[i].style.border = 'solid .1px lightgray'
            spans[i].classList.remove(spans[i].getAttribute('class'))
            spans[i].className = 'blank'
            spans[i].style.background = 'ghostwhite'
            spans[i].style.borderRadius = '0%'
          }
        }
      }
    }
      //The inside function for fillR
      function fillCol(i, j, parNum, first) {
        //Checking which coordinate system to use
        if (first === true) {
          elem = document.getElementById(i + 'n' + j)
        } else if (first === false){
          elem = document.getElementById(j + 'n' + i)
        }
        elCl = elem.getAttribute('class')
        //If it's the second path in a row one's seen, don't fill stuff in
        //(it's a line, and is unpredictable. Sometimes this can mean a spot is left unfilled)
        //Still increase parity, to even the score from the last one
        if (elCl === 'charPath' && line === true && dont === false) {
          parity[parNum] = parity[parNum] + 1
          dont = true; end = true;
        //If it's the first path one's seen recently, increase parity
        } else if (elCl === 'charPath' && line === false) {
          parity[parNum] = parity[parNum] + 1
          line = true; dont = false;
        //If it's blank, parity is odd (mathy stuff), and you're not following a line:
        //Save the space to fill in later
        } else if (elCl === 'blank' && parity[parNum]%2 != 0 && dont === false) {
          line = false; dont = false;
          elem.classList.remove('blank'); elem.className = 'charTerPoss';
          elem.style.background = 'purple'
          //If it's blank but parity is even or one's following a line, set this space as NOT territory,
          //and remove it later if another run flags it as territory
        } else if (elCl === 'blank') {
          line = false; dont = false;
          remover.push(elem.getAttribute('id'))
          //If it's a berry, treat it as a blank, but don't change it's border-radius
          //(this will signify that it's an ex-berry for later)
        } else if (elCl === 'berry' && parity[parNum]%2 != 0 && dont === false) {
          line = false; dont = false;
          elem.classList.remove('berry'); elem.className = 'charTerPoss'
          elem.style.background = 'purple'
          //Just like a blank, if parity is even or it's following a line, save it for
          //removal at a later date
        } else if (elCl === 'berry') {
          line = false; dont = false;
          remover.push(elem.getAttribute('id'))
          //If it's a territory, just end the process. It's easier that way, and usually more accurate
        } else if (elCl === 'charTer' || elCl === 'charTerP'){
          end = true; line = false; dont = false;
          //If it's a possible territory and now has even parity, save it for removal later
          //So, all runs must agree before it is added in a definite first run
        } else if (elCl === 'charTerPoss' && parity[parNum]%2 == 0 && dont === false) {
          line = false; remover.push(elem.getAttribute('id'));
        }
      }

      //Does a seed fill for any pesky remaining blanks
      //It starts with every inner-territory (the innards), and does a seed-fill
      //It checks the four adjacent spans, then if any one is a blank, it repeats
      //for this new territory, until all adjacent spans are filled
      function innardsCheck(inns) {
        newInnards = []
        inns.forEach(function(inn, id) {
          let x = parseInt(inn.split('n')[0], 10)
          let y = parseInt(inn.split('n')[1], 10)
          var places = []
          places[0] = document.getElementById((x + 1) + 'n' + y)
          places[1] = document.getElementById((x - 1) + 'n' + y)
          places[2] = document.getElementById(x + 'n' + (y + 1))
          places[3] = document.getElementById(x + 'n' + (y - 1))
          places.forEach(function(pl, id2) {
            if (pl) {
              plCl = pl.getAttribute('class')
              //If it's a blank or berry, turn it to territory and run the id through
              if (plCl === 'blank') {
                pl.classList.remove('blank'); pl.className = 'charTer';
                pl.style.background = charTerColI
                newInnards.push(pl.getAttribute('id'))
              } else if (plCl === 'berry') {
                seedNum++
                pl.classList.remove('berry'); pl.className = 'charTer';
                pl.style.background = charTerColI
                newInnards.push(pl.getAttribute('id'))
              }
            }
          })
          //If there are any new territories, run it again for them
          if (newInnards[0]) { innardsCheck(newInnards) }
        })
      }

  //Fill in territory once a path is completed
    function fillR() {
      var maxX = 0; var minX = 55; arrX = [];
      var maxY = 0; var minY = 55; arrY = [];
      innards = []; remover = [];
      //Fill an array with all preexisting territory/paths,
      //and use this to determine min-maxes for each row and column sweep
      let paths = document.getElementsByClassName('charPath')
      let terrs = document.getElementsByClassName('charTer')
      let terrPs = document.getElementsByClassName('charTerP')
      let borders = [...paths, ...terrs, ...terrPs]
      for (i = 0; i < borders.length; i++) {
        var pathId = borders[i].getAttribute('id')
        arrX.push(parseInt(pathId.split('n')[0], 10))
        arrY.push(parseInt(pathId.split('n')[1], 10))
      }
      //Find max/min columns and rows
      for (i in arrX) {
        if (arrX[i] < minX) { minX = arrX[i]; }
        if  (arrX[i] > maxX) { maxX = arrX[i]; }
      }
      for (i in arrY) {
        if (arrY[i] < minY) { minY = arrY[i]; }
        if  (arrY[i] > maxY) { maxY = arrY[i]; }
      }
      //Sort through rows both directions, and then columns both directions when the function
      //is called with reversed values
      var kArray = []
      function sortR(minC, maxC, arrC, arrR, p, first) {
        for (i = minC; i <= maxC; i++) {
          //Recalculating min/max for each line as you sweep
          var minR = 55; var maxR = 0; kArray = [];
          arrR.forEach(function(k, l) {
            if (arrC[l] === i) { kArray.push(k); }
          })
          for (var m of kArray) {
            if (m < minR) { minR = m;}
            if (m > maxR) { maxR = m;}
          }
          //Sorting rows top to bottom
          parity = [0,0,0,0]
          line = false; end = false; dont = false;
          for (j = minR; j <= maxR; j++) {
            if (end === false) { fillCol(i, j, (0 + p), first); }
          }
          //Sorting rows bottom to top
          parity = [0,0,0,0]
          line = false; end = false; dont = false;
          for (j = maxR; j >= minR; j--) {
            if (end === false) { fillCol(i, j, (1 + p), first); }
          }
        }
      }
      //Calling for rows and columns
      sortR(minX, maxX, arrX, arrY, 0, true); sortR(minY, maxY, arrY, arrX, 2, false);
      //Turns all the paths into territory
      for (i = 0; i < paths.length; i = i) {
        elem = paths[i]
        elem.classList.remove('charPath'); elem.className = 'charTerP';
        elem.style.background = charTerColP
      }
      //Remove all prospies that didn't make the cut
      for (i = 0; i < remover.length; i++) {
        removed = document.getElementById(remover[i])
        if (removed) {
          removed.classList.remove('charTerPoss'); removed.className = 'blank';
          //If the prospie was a berry, give it back it's yellow hue
          if (removed.style.borderRadius === '50%') {
            removed.style.background = berryCol
          } else {
            removed.style.background = 'ghostwhite'
          }
        }
      }
      //Turn all accepted prospies into territory
      possies = document.getElementsByClassName('charTerPoss')
      for (var i = 0; i < possies.length; i = i) {
        poss = possies[i]; possId = poss.getAttribute('id');
        poss.classList.remove('charTerPoss'); poss.className = 'charTer';
        poss.style.background = charTerColI
        //Do a bit extra for prospie ex-berries
        if (poss.style.borderRadius === '50%') {
          poss.style.borderRadius = '0%'
          if (checkArr[3]) {
            stamina = Math.round(stamina + enerPlus)
          } else {
            stamina = Math.round(stamina + stamPlus)
          }
          seedNum++
        }
        //Push all new territories to the innards seed-fill run
        innards.push(possId)
      }
      //Run the innards seed-fill with these new found values, and update stats afterwards
      innardsCheck(innards); statZ();
    }
    //Update stats and check whether the player has won
    function statZ() {
      //Checking the territory percentage which is
      //the effective number of territories divided by the initial number of blank spaces
      nBlankNum = document.body.getElementsByClassName('blank').length
      nSeedNum = document.body.getElementsByClassName('berry').length
      nPathNum = document.body.getElementsByClassName('charPath').length
      filledFrac = ((sBlankNum - nBlankNum -nSeedNum - nPathNum)/sBlankNum)
      //Update the percentage of the map that's territory
      barPerc.innerHTML = (filledFrac*100).toFixed(2) + '% of the Map'
      //If there's energy, update that too
      if (checkArr[1] || checkArr[3]) {
        barStam.innerHTML = 'ENERGY: ' + Math.round(stamina)/1000
      }
      //If the number of collected seeds is counted, update that as well
      if (checkArr[2]) {
        barSeed.innerHTML = 'SEEDS: ' + seedNum
        //If you get all the seeds, you win (and thus die)
        if (seedNum === startSeedNum) {
          win = true; seedWin = true;
          //If you've simulaneously covered the whole board, you get both wins!
          if (filledFrac === 1) { terrWin = true; }
          deathScene(true)
        }
      //If you win, you die, otherwise if you pass a milestone percentage, the
      //new character laying colors are different
      }
      if (filledFrac === 1) {
        win = true; terrWin = true; deathScene(true);
      } else if (filledFrac > .8) {
        colChange(4)
      } else if (filledFrac > .6) {
        colChange(3)
      } else if (filledFrac > .4) {
        colChange(2)
      } else if (filledFrac > .2) {
        colChange(1)
      }
    }

    //Create the map and start the game rolling
    function mapMake() {
      //Set the initial mapX and mapY for map centering
      if (mapXNum%2 === 0) {
        mapX = -Math.round(32.2*((mapXNum-2)/2)) + (window.innerWidth/2)
      } else {
        mapX = -Math.round(32.2*((mapXNum-1)/2)) + (window.innerWidth/2)
      }
      if (mapYNum%2 === 0) {
        mapY = -Math.round(32.2*((mapYNum-2)/2)) + (window.innerHeight/2)
      } else {
        mapY = -Math.round(32.2*((mapYNum-1)/2)) + (window.innerHeight/2)
      }
      lefts = mapX; ups = mapY;
      //Do the first centering of the map, and adjust the body and map size to the num of rows and columns
      mappy.style.margin = '' + ups + 'px 0 0 ' + lefts + 'px';
      document.body.style.width = mapXNum * sSize + 'px'
      document.body.style.height = mapYNum * sSize + 'px'
      mappy.style.width = mapXNum * sSize + 'px'
      mappy.style.height = mapYNum * sSize + 'px'
      //The actual process of populating the map with blank spans, row by row and column by column
      //The ids reflect the row and column numbers for quick recall later
      for (let i = 0; i < mapYNum; i++) {
        let rowDiv = document.createElement('div')
        rowDiv.id = 'row' + i; rowDiv.className = 'rows';
        rowDiv.style.width = (mapXNum * 32.2) + 'px'
        document.getElementById('map').appendChild(rowDiv)
        for (let j = 0; j < mapXNum; j++) {
          let elem = document.createElement('span')
          elem.id = '' + j + 'n' + i + ''; elem.className = 'blank';
          document.getElementById('row' + i).appendChild(elem)
        }
      }
    }

    //Start the game and reset/set up variables and arrays
    function gameStart() {
      //If you're restarting from the death screen, wait a bit to start
      //to allow for a smooth zoom back in to the board
      if (replay) {
        moveSpeed = setTimeout( function() {
          char.style.display = 'block'
          mappy.style.transition = 'margin linear 200ms'
          moving = setInterval(function() {mapMove();}, 200)
        }, 1500)
      }
      //If the character has won recently, give them the win colors
      if (!win) { colChange(0); } else { colChange(5); }
      //Reset values, center the map, and place the character with starting territory
      deathScene(false); mapCenter(); terrStart(); charStart();
      //Set up seeds if the game is in that mode
      if (checkArr[1] || checkArr[2] || checkArr[3]) {
        var seedVal
        //Give less seeds for Hungry Character; it's more fun that way
        if (checkArr[3]) { seedVal = 20; } else { seedVal = 25; }
        startSeedNum = Math.round(mapXNum*mapYNum/seedVal)
        seedPopulate(startSeedNum)
      }
      //Setup the Stat Bar and some starting values
      sBlankNum = document.getElementsByClassName('blank').length
      document.body.appendChild(sBar); statZ();
      congrats.innerHTML = ''; barStam.innerHTML = ''; barSeed.innerHTML = '';
      //Start centering map continously, every second or so
      setInterval(function() {mapCenter();}, 1000)
    }

    //FUNCTIONS FOR THE INSIDE OF setUpScreen()
    //Puts break between lines
    function brk(holdr) {
      let brk = document.createElement('br'); holdr.append(brk);
    }
    //Puts informational text around inputs
    function txtr(idT, id, fill, holdr, x, y, fWeight) {
      let text = document.createElement('label')
      text.innerHTML = fill; text.className = 'info';
      if (idT) {text.htmlFor = id;}
      text.style.fontWeight = fWeight
      text.style.margin = '' + x + 'px 0 0 ' + y + 'px'
      holdr.appendChild(text)
    }
    //Makes clicker miniHolders
    function holdMaker(id) {
      let holder = document.getElementById('holder')
      let holdere = document.createElement('div')
      holdere.className = 'holder'; holdere.id = 'hold' + id;
      holder.appendChild(holdere); return holdere;
    }
    //Makes mode clickers
    function modeMaker(info, num, marg) {
      let checker = document.createElement('input')
      checker.className = 'checker'; checker.id = 'checker' + (num + 1);
      checker.type = 'checkbox';
      if (checkArr[num]) {checker.checked = true;}
      checker.style.margin = '' + marg + 'px 0 0 10px'
      brk(minHold1); minHold1.appendChild(checker); txtr(true, 'checker' + (num + 1), info, minHold1);
      return checker
    }
    //Makes size input boxes
    function sizeMaker(deflt, info, id, marg) {
      let mapSize = document.createElement('input')
      mapSize.id = 'map' + id; mapSize.className = 'mapSize';
      mapSize.type = 'type'; mapSize.defaultValue = deflt;
      mapSize.style.margin = '' + (20 + marg) + 'px 0 0 10px'
      brk(minHold2); txtr(true, 'map' + id, info, minHold2, 20, 10);
      minHold2.appendChild(mapSize); return mapSize;
    }
    //Make shape choices
    function radioMaker(val, name, label, num, marg) {
      let mapShape = document.createElement('input')
      mapShape.type = 'radio'; mapShape.id = '' + name + num + '';
      mapShape.value = val; mapShape.name = name;
      mapShape.style.margin = '' + marg + 'px 0 0 10px';
      brk(minHold3); minHold3.appendChild(mapShape); txtr(true, name + num, label, minHold3);
      if (shp === val) { mapShape.checked = true; }
      return mapShape
    }
    //Store picked values into the game before starting, if one has just come from the starting screen
    function gameFromMenu(lTC, tHC, sSC, hCC, mX, mY, s1, s2, s3) {
      //Check that the mpa values are valid numbers within a reasonable range
      //If they're not, say so and say why
      if (isNaN(mX.value) || isNaN(mY.value)) {
        alert('One of your map values is not a valid number'); retry = true;
      } else if (mX.value < 3 || mY.value < 3) {
        alert('One of your map values is too small (it should be at least 3)'); retry = true;
      } else if (mX.value > 150 || mY.value > 150) {
        alert('One of your map values is too large (over 150 and the page crashes)'); retry = true;
      } else { retry = false; }
      //If you're good to go:
      if (!retry) {
        //Set up the mode values
        function checkFill(checker, num) { checkArr[num] = checker.checked; }
        checkFill(lTC, 0); checkFill(tHC, 1); checkFill(sSC, 2); checkFill(hCC, 3);
        //Set up the map size values
        if (mX.value) { mapXNum = mX.value; }; if (mY.value) { mapYNum = mY.value; };
        //Set up the map shape values
        if (s1.checked) { shp = 'default'; } else if (s2.checked) { shp = 'circle'; } else if (s3.checked) { shp = 'triangle';}
        //Start setting up the map, fill the map, and start the game
        document.body.removeChild(holder); document.body.appendChild(mappy);
        mapMake();
        moving = setInterval(function() {mapMove();}, 200)
        char.style.display = 'block'; mappy.style.transition = 'margin linear 200ms';
        gameStart()
      }
    }
    //Dynamically makes the start-up screen/menu
    function setUpScreen() {
      //Holder for ev'thing
      holder = document.createElement('div')
      holder.id = 'holder'; document.body.appendChild(holder);
      //Start Button
      let start = document.createElement('button')
      start.id = 'beginner'; start.className = 'start';
      start.innerHTML = 'Start'; start.type = 'button';
      holder.appendChild(start)
      //Mode Checker Holder
      minHold1 = holdMaker(1)
      txtr(false, null, 'Game Modes:', minHold1, 30, 10, 'bold')
      let checker1 = modeMaker('Lava Territory', 0, 10);
      let checker2 = modeMaker('Timed Hunting', 1);
      let checker3 = modeMaker('Seed Saver', 2);
      let checker4 = modeMaker('Hungry Character', 3);
      //Map Size Holder
      minHold2 = holdMaker(2)
      txtr(false, null, 'Map Size:', minHold2, 30, 10, 'bold')
      let mapHor = sizeMaker(mapXNum, 'Map Width', 'Hor', 0)
      let mapVert = sizeMaker(mapYNum, 'Map Height', 'Vert', 0)
      //Map Shape Holder
      minHold3 = holdMaker(3)
      txtr(false, null, 'Map Shape:', minHold3, 30, 10, 'bold')
      let shape0 = radioMaker('default', 'shape', 'Default', 0, 10)
      let shape1 = radioMaker('circle', 'shape', 'Circle', 1)
      let shape2 = radioMaker('triangle', 'shape', 'Triangle', 2)
      //Sets up start-click function
      start.onclick = function() {gameFromMenu(checker1, checker2, checker3, checker4, mapHor, mapVert, shape0, shape1, shape2);}
    }
    //Start the game with the start-up screen
    setUpScreen()
  </script>
</body>
</html>
